                              1 ;--------------------------------------------------------
                              2 ; File Created by SDCC : free open source ANSI-C Compiler
                              3 ; Version 3.5.2 #9293 (MINGW32)
                              4 ; This file was generated Tue Nov 13 17:35:28 2018
                              5 ;--------------------------------------------------------
                              6 	.module aPLib
                              7 	.optsdcc -mz80
                              8 	
                              9 ;--------------------------------------------------------
                             10 ; Public variables in this module
                             11 ;--------------------------------------------------------
                             12 	.globl _aPLib_depack_VRAM
                             13 	.globl _aPLib_R0
                             14 	.globl _aPLib_LWM
                             15 	.globl _aPLib_bits
                             16 ;--------------------------------------------------------
                             17 ; special function registers
                             18 ;--------------------------------------------------------
                             19 ;--------------------------------------------------------
                             20 ; ram data
                             21 ;--------------------------------------------------------
                             22 	.area _DATA
   0000                      23 _aPLib_bits::
   0000                      24 	.ds 2
   0002                      25 _aPLib_LWM::
   0002                      26 	.ds 1
   0003                      27 _aPLib_R0::
   0003                      28 	.ds 2
                             29 ;--------------------------------------------------------
                             30 ; ram data
                             31 ;--------------------------------------------------------
                             32 	.area _INITIALIZED
                             33 ;--------------------------------------------------------
                             34 ; absolute external ram data
                             35 ;--------------------------------------------------------
                             36 	.area _DABS (ABS)
                             37 ;--------------------------------------------------------
                             38 ; global & static initialisations
                             39 ;--------------------------------------------------------
                             40 	.area _HOME
                             41 	.area _GSINIT
                             42 	.area _GSFINAL
                             43 	.area _GSINIT
                             44 ;--------------------------------------------------------
                             45 ; Home
                             46 ;--------------------------------------------------------
                             47 	.area _HOME
                             48 	.area _HOME
                             49 ;--------------------------------------------------------
                             50 ; code
                             51 ;--------------------------------------------------------
                             52 	.area _CODE
                             53 ;lib/aPLib.c:25: void aPLib_depack_VRAM (unsigned int dest, void *src) {
                             54 ;	---------------------------------
                             55 ; Function aPLib_depack_VRAM
                             56 ; ---------------------------------
   0000                      57 _aPLib_depack_VRAM::
                             58 ;lib/aPLib.c:269: __endasm;
   0000 C1            [10]   59 	pop bc
   0001 D1            [10]   60 	pop de
   0002 E1            [10]   61 	pop hl
   0003 E5            [11]   62 	push hl
   0004 D5            [11]   63 	push de
   0005 C5            [11]   64 	push bc
   0006 C3rA0r00      [10]   65 	jp vram_depack
   0009                      66 	ap_VRAMToDE_write:
   0009 F5            [11]   67 	push af
   000A 7B            [ 4]   68 	ld a,e
   000B F3            [ 4]   69 	di
   000C D3 BF         [11]   70 	out (0xbf),a
   000E 7A            [ 4]   71 	ld a,d
   000F F6 40         [ 7]   72 	or #0x40
   0011                      73 	_minus1:
   0011 D3 BF         [11]   74 	out (0xbf),a
   0013 FB            [ 4]   75 	ei
   0014 F1            [10]   76 	pop af
   0015 C9            [10]   77 	ret
   0016                      78 	ap_VRAMToHL_read:
   0016 F5            [11]   79 	push af
   0017 7D            [ 4]   80 	ld a,l
   0018 F3            [ 4]   81 	di
   0019 D3 BF         [11]   82 	out (0xbf),a
   001B 7C            [ 4]   83 	ld a,h
   001C 18 F3         [12]   84 	jr _minus1 ; space optimisation
   001E                      85 	ap_VRAM_ldi_src_to_dest:
   001E CDr09r00      [17]   86 	call ap_VRAMToDE_write
   0021 C5            [11]   87 	push bc
   0022 0E BE         [ 7]   88 	ld c,#0xbe
   0024 ED A3         [16]   89 	outi
   0026 C1            [10]   90 	pop bc
   0027 0B            [ 6]   91 	dec bc
   0028 13            [ 6]   92 	inc de
   0029 C9            [10]   93 	ret
   002A                      94 	ap_VRAM_ldir_dest_to_dest:
                             95 ; This may be a major speed bottleneck
                             96 ; possibly could take some stack space for a buffer? but that would need a lot more code space
                             97 ; if it uses overlapping source/dest then a buffer will break it
   002A F5            [11]   98 	push af
   002B                      99 	_minus2:
   002B CDr16r00      [17]  100 	call ap_VRAMToHL_read
   002E DB BE         [11]  101 	in a,(0xbe)
   0030 CDr09r00      [17]  102 	call ap_VRAMToDE_write
   0033 D3 BE         [11]  103 	out (0xbe),a
   0035 0B            [ 6]  104 	dec bc
   0036 13            [ 6]  105 	inc de
   0037 23            [ 6]  106 	inc hl
   0038 78            [ 4]  107 	ld a,b
   0039 B1            [ 4]  108 	or c
   003A 20 EF         [12]  109 	jr nz,_minus2
   003C F1            [10]  110 	pop af
   003D C9            [10]  111 	ret
   003E                     112 	_vram_apbranch2:
                            113 ;use a gamma code * 256 for offset, another gamma code for length
   003E CDr26r01      [17]  114 	call ap_getgamma
   0041 0B            [ 6]  115 	dec bc
   0042 0B            [ 6]  116 	dec bc
   0043 3Ar02r00      [13]  117 	ld a,(_aPLib_LWM)
   0046 B7            [ 4]  118 	or a
   0047 20 19         [12]  119 	jr nz,_vram_ap_not_LWM
                            120 ;bc = 2? ; Maxim: I think he means 0
   0049 78            [ 4]  121 	ld a,b
   004A B1            [ 4]  122 	or c
   004B 20 14         [12]  123 	jr nz,_vram_ap_not_zero_gamma
                            124 ;if gamma code is 2, use old R0 offset, and a new gamma code for length
   004D CDr26r01      [17]  125 	call ap_getgamma
   0050 E5            [11]  126 	push hl
   0051 62            [ 4]  127 	ld h,d
   0052 6B            [ 4]  128 	ld l,e
   0053 C5            [11]  129 	push bc
   0054 ED 4Br03r00   [20]  130 	ld bc,(_aPLib_R0)
   0058 ED 42         [15]  131 	sbc hl,bc
   005A C1            [10]  132 	pop bc
   005B CDr2Ar00      [17]  133 	call ap_VRAM_ldir_dest_to_dest
   005E E1            [10]  134 	pop hl
   005F 18 2F         [12]  135 	jr _vram_ap_finishup
   0061                     136 	_vram_ap_not_zero_gamma:
   0061 0B            [ 6]  137 	dec bc
   0062                     138 	_vram_ap_not_LWM:
                            139 ;do I even need this code? ; Maxim: seems so, it is broken without it
                            140 ;bc=bc*256+(hl), lazy 16bit way
   0062 41            [ 4]  141 	ld b,c
   0063 4E            [ 7]  142 	ld c,(hl)
   0064 23            [ 6]  143 	inc hl
   0065 ED 43r03r00   [20]  144 	ld (_aPLib_R0),bc
   0069 C5            [11]  145 	push bc
   006A CDr26r01      [17]  146 	call ap_getgamma
   006D E3            [19]  147 	ex (sp),hl
                            148 ;bc = len, hl=offs
   006E D5            [11]  149 	push de
   006F EB            [ 4]  150 	ex de,hl
                            151 ;some comparison junk for some reason
                            152 ; Maxim: optimised to use add instead of sbc
   0070 21 00 83      [10]  153 	ld hl,#-32000
   0073 19            [11]  154 	add hl,de
   0074 30 01         [12]  155 	jr nc,_plus5
   0076 03            [ 6]  156 	inc bc
   0077                     157 	_plus5:
   0077 21 00 FB      [10]  158 	ld hl,#-1280
   007A 19            [11]  159 	add hl,de
   007B 30 01         [12]  160 	jr nc,_plus6
   007D 03            [ 6]  161 	inc bc
   007E                     162 	_plus6:
   007E 21 80 FF      [10]  163 	ld hl,#-128
   0081 19            [11]  164 	add hl,de
   0082 38 02         [12]  165 	jr c,_plus7
   0084 03            [ 6]  166 	inc bc
   0085 03            [ 6]  167 	inc bc
   0086                     168 	_plus7:
                            169 ;bc = len, de = offs, hl=junk
   0086 E1            [10]  170 	pop hl
   0087 E5            [11]  171 	push hl
   0088 B7            [ 4]  172 	or a
   0089 ED 52         [15]  173 	sbc hl,de
   008B D1            [10]  174 	pop de
                            175 ;hl=dest-offs, bc=len, de = dest
   008C CDr2Ar00      [17]  176 	call ap_VRAM_ldir_dest_to_dest
   008F E1            [10]  177 	pop hl
   0090                     178 	_vram_ap_finishup:
   0090 3E 01         [ 7]  179 	ld a,#1
   0092 32r02r00      [13]  180 	ld (_aPLib_LWM),a
   0095 18 14         [12]  181 	jr _vram_aploop
   0097                     182 	_vram_apbranch1:
                            183 ; Maxim: moved this one closer to where it is jumped from to allow jr to work and save 2 bytes
   0097 CDr1Er00      [17]  184 	call ap_VRAM_ldi_src_to_dest
   009A AF            [ 4]  185 	xor a
   009B 32r02r00      [13]  186 	ld (_aPLib_LWM),a
   009E 18 0B         [12]  187 	jr _vram_aploop
   00A0                     188 	vram_depack:
                            189 ;hl = source
                            190 ;de = dest (in VRAM)
                            191 ;VRAM addresses are assumed to be stable (ie. di/ei around it)
   00A0 CDr1Er00      [17]  192 	call ap_VRAM_ldi_src_to_dest ; first byte is always uncompressed
   00A3 AF            [ 4]  193 	xor a
   00A4 32r02r00      [13]  194 	ld (_aPLib_LWM),a
   00A7 3C            [ 4]  195 	inc a
   00A8 32r00r00      [13]  196 	ld (_aPLib_bits),a
   00AB                     197 	_vram_aploop:
   00AB CDr09r01      [17]  198 	call ap_getbit
   00AE 28 E7         [12]  199 	jr z, _vram_apbranch1
   00B0 CDr09r01      [17]  200 	call ap_getbit
   00B3 28 89         [12]  201 	jr z, _vram_apbranch2
   00B5 CDr09r01      [17]  202 	call ap_getbit
   00B8 28 2C         [12]  203 	jr z, _vram_apbranch3
                            204 ;LWM = 0
   00BA AF            [ 4]  205 	xor a
   00BB 32r02r00      [13]  206 	ld (_aPLib_LWM),a
                            207 ;get an offset
   00BE 01 00 00      [10]  208 	ld bc,#0
   00C1 CDr1Cr01      [17]  209 	call ap_getbitbc
   00C4 CDr1Cr01      [17]  210 	call ap_getbitbc
   00C7 CDr1Cr01      [17]  211 	call ap_getbitbc
   00CA CDr1Cr01      [17]  212 	call ap_getbitbc
   00CD 78            [ 4]  213 	ld a,b
   00CE B1            [ 4]  214 	or c
   00CF 20 08         [12]  215 	jr nz,_vram_apbranch4
                            216 ; xor a ;write a 0 ; Maxim: a is zero already (just failed nz test), optimise this line away
   00D1                     217 	_WriteAToVRAMAndLoop:
   00D1 CDr09r00      [17]  218 	call ap_VRAMToDE_write
   00D4 D3 BE         [11]  219 	out (0xbe),a
   00D6 13            [ 6]  220 	inc de
   00D7 18 D2         [12]  221 	jr _vram_aploop
   00D9                     222 	_vram_apbranch4:
   00D9 EB            [ 4]  223 	ex de,hl ;write a previous bit (1-15 away from dest)
   00DA E5            [11]  224 	push hl
   00DB ED 42         [15]  225 	sbc hl,bc
   00DD CDr16r00      [17]  226 	call ap_VRAMToHL_read
   00E0 DB BE         [11]  227 	in a,(0xbe)
   00E2 E1            [10]  228 	pop hl
   00E3 EB            [ 4]  229 	ex de,hl
   00E4 18 EB         [12]  230 	jr _WriteAToVRAMAndLoop
   00E6                     231 	_vram_apbranch3:
                            232 ;use 7 bit offset, length = 2 or 3
                            233 ;if a zero is encountered here, it is EOF
   00E6 4E            [ 7]  234 	ld c,(hl)
   00E7 23            [ 6]  235 	inc hl
   00E8 CB 19         [ 8]  236 	rr c
   00EA C8            [11]  237 	ret z
   00EB 06 02         [ 7]  238 	ld b,#2
   00ED 30 01         [12]  239 	jr nc,_plus8
   00EF 04            [ 4]  240 	inc b
   00F0                     241 	_plus8:
                            242 ;LWM = 1
   00F0 3E 01         [ 7]  243 	ld a,#1
   00F2 32r02r00      [13]  244 	ld (_aPLib_LWM),a
   00F5 E5            [11]  245 	push hl
   00F6 78            [ 4]  246 	ld a,b
   00F7 06 00         [ 7]  247 	ld b,#0
                            248 ;R0 = c
   00F9 ED 43r03r00   [20]  249 	ld (_aPLib_R0),bc
   00FD 62            [ 4]  250 	ld h,d
   00FE 6B            [ 4]  251 	ld l,e
   00FF B7            [ 4]  252 	or a
   0100 ED 42         [15]  253 	sbc hl,bc
   0102 4F            [ 4]  254 	ld c,a
   0103 CDr2Ar00      [17]  255 	call ap_VRAM_ldir_dest_to_dest
   0106 E1            [10]  256 	pop hl
   0107 18 A2         [12]  257 	jr _vram_aploop
   0109                     258 	ap_getbit:
   0109 C5            [11]  259 	push bc
   010A ED 4Br00r00   [20]  260 	ld bc,(_aPLib_bits)
   010E CB 09         [ 8]  261 	rrc c
   0110 30 02         [12]  262 	jr nc,_plus9
   0112 46            [ 7]  263 	ld b,(hl)
   0113 23            [ 6]  264 	inc hl
   0114                     265 	_plus9:
   0114 79            [ 4]  266 	ld a,c
   0115 A0            [ 4]  267 	and b
   0116 ED 43r00r00   [20]  268 	ld (_aPLib_bits),bc
   011A C1            [10]  269 	pop bc
   011B C9            [10]  270 	ret
   011C                     271 	ap_getbitbc:
                            272 ;doubles BC and adds the read bit
   011C CB 21         [ 8]  273 	sla c
   011E CB 10         [ 8]  274 	rl b
   0120 CDr09r01      [17]  275 	call ap_getbit
   0123 C8            [11]  276 	ret z
   0124 03            [ 6]  277 	inc bc
   0125 C9            [10]  278 	ret
   0126                     279 	ap_getgamma:
   0126 01 01 00      [10]  280 	ld bc,#1
   0129                     281 	_minus3:
   0129 CDr1Cr01      [17]  282 	call ap_getbitbc
   012C CDr09r01      [17]  283 	call ap_getbit
   012F 20 F8         [12]  284 	jr nz,_minus3
   0131 C9            [10]  285 	ret
   0132 C9            [10]  286 	ret
                            287 	.area _CODE
                            288 	.area _INITIALIZER
                            289 	.area _CABS (ABS)
